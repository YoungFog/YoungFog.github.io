<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>void*实现泛型编程</title>
      <link href="2021/05/02/5.wu-lei-xing-zhi-zhen-shi-xian-fan-xing-bian-cheng/"/>
      <url>2021/05/02/5.wu-lei-xing-zhi-zhen-shi-xian-fan-xing-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><hr><p>若<code>typename *p</code>是指向某类型的指针：在常规情况下，p指向的内存，存放着typename类型的数据。</p><ul><li><code>p += n</code>意味着 <code>p += n * sizeof(typename)</code> 。</li><li><code>*p</code>意味着从p开始取<code>sizeof(typename)</code>个字节，以typename类型进行数据读取。</li></ul><p>然而( 尤其是C语言 )很多情况下，我们并不能确定数据的类型。</p><p>如果直接定义具体的<code>typename *</code>的指针，则无法实现接口函数的重用性，编程效率大大降低。</p><p>那么特殊的typename— <code>void</code>能不能帮我们解决这一问题？</p><h1 id="无类型指针"><a href="#无类型指针" class="headerlink" title="无类型指针"></a>无类型指针</h1><hr><p><code>void*</code> ，即无类型指针。</p><blockquote><p>区分空指针：typename* p = NULL </p></blockquote><h2 id="1-void-的使用规则"><a href="#1-void-的使用规则" class="headerlink" title="1. void*的使用规则"></a>1. void*的使用规则</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无类型指针可以指向任意类型（因此可作为参数，实现泛型编程）</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无类型指针通过强制类型转换，赋值给其他类型指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为指向void，所以<strong>p += n 和 * p均是无意义的</strong> [ ANSI标准下会报错，GNU当成char*的来运算 ] 。</p><p>但我们可以用 <strong>p += n * sizeof(typename) 和 * (typename * ) p</strong> 来实现自定义类型的操作。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 定义 */</span><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 运算 */</span><span class="token operator">++</span>p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不合法</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不合法</span>p <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确(GNU)</span><span class="token comment" spellcheck="true">//最后输出结果为： 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-常见的void-实例"><a href="#2-常见的void-实例" class="headerlink" title="2. 常见的void*实例"></a>2. 常见的void*实例</h2><p><strong>作为返回值：</strong></p><p>内存分配函数 <code>malloc</code> 的返回值就是<code>void*</code>型指针。</p><p>一般调用时，我们会用到强制类型转换。即形如<code>(int*)malloc(sizeof(int))</code>的使用方式。</p><p><strong>作为参数：</strong></p><p>内存拷贝函数 <code>void* memcpy(void *dest, const void *src, size_t len)</code>参数就是<code>void*</code>型指针。</p><p>之前提过无类型指针可以指向任意类型，即<strong>可接收任意类型指针的赋值</strong>。</p><p>在调用时，若p1和p2均为char类型的指针，<code>memcpy(p1, p2, sizeof(char))</code>，则将 从p2开始的sizeof(char)字节的内存 拷贝到 从p1开始的sizeof(char)字节内存中。</p><h1 id="void-的泛型编程"><a href="#void-的泛型编程" class="headerlink" title="void*的泛型编程"></a>void*的泛型编程</h1><hr><p>泛型编程，即编写<strong>完全一般化且可重复使用</strong>的算法来提高编程效率</p><h2 id="1-例一"><a href="#1-例一" class="headerlink" title="1. 例一"></a>1. 例一</h2><p>让我们先看一个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 交换值 */</span><span class="token comment" spellcheck="true">// int</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// float</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">float</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了不重复编写，我们可以使用无类型指针<code>void*</code>来接受不同类型指针的参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>p2<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前提是GCC编译器</span>    <span class="token comment" spellcheck="true">// 分配size个字节的内存</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，我们调用swap，可以像如下这样操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-例二"><a href="#2-例二" class="headerlink" title="2. 例二"></a>2. 例二</h2><p>接下来，我们再看一个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 查找(返回下标) */</span><span class="token comment" spellcheck="true">// int</span><span class="token keyword">int</span> <span class="token function">Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// float</span><span class="token keyword">int</span> <span class="token function">Search</span><span class="token punctuation">(</span><span class="token keyword">float</span> key<span class="token punctuation">,</span> <span class="token keyword">float</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>void*</code>改造为泛型函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 查找(返回地址) */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Search</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>elementAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以1字节为基本单位[char为1字节]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">memcmp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> elementAddress<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>elementAddress<span class="token punctuation">;</span>       elementAddress <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，我们调用Search，可以像如下这样操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">Search</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">,</span> array<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Found -- "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>result<span class="token punctuation">;</span><span class="token keyword">else</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Not Found"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果：Found -- 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-例三"><a href="#3-例三" class="headerlink" title="3. 例三"></a>3. 例三</h2><p>最后，让我们基于例二拓展一下，实现<strong>行为的泛型化</strong>。</p><p>在例二中，Search函数中调用了memcmp函数，即包含了“内存比较”这一<strong>行为</strong>。</p><p>而在实际应用中，我们可能要使用到<strong>各种不同规则的比较行为</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 行为 1 —— 比较int的大小 */</span><span class="token keyword">int</span> <span class="token function">IntCmp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> elem1<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> elem2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ip1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>elem1<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ip2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>elem2<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>ip1<span class="token operator">-</span><span class="token operator">*</span>ip2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 行为 2 —— 比较长方体(结构体)的宽度 */</span><span class="token keyword">struct</span> Cuboid<span class="token punctuation">{</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token keyword">int</span> wide<span class="token punctuation">;</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Cuboid_WideCmp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> elem1<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> elem2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ip1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Cuboid<span class="token operator">*</span><span class="token punctuation">)</span>elem1<span class="token punctuation">)</span><span class="token punctuation">.</span>wide<span class="token punctuation">;</span>    <span class="token keyword">int</span> ip2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Cuboid<span class="token operator">*</span><span class="token punctuation">)</span>elem2<span class="token punctuation">)</span><span class="token punctuation">.</span>wide<span class="token punctuation">;</span>    <span class="token keyword">return</span> ip1<span class="token operator">-</span>ip2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于以上不同的行为，均可使用<strong>函数指针</strong>，实现行为的泛型化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 查找(返回地址) */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Search</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>cmp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>elementAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>base<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以1字节为基本单位[char为1字节]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> elementAddress<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>elementAddress<span class="token punctuation">;</span>       elementAddress <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 行为 1 —— 比较int的大小 */</span><span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> key1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">Search</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key1<span class="token punctuation">,</span> array1<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IntCmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Found -- "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>result<span class="token punctuation">;</span><span class="token keyword">else</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Not Found"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果：Found -- 2</span><span class="token comment" spellcheck="true">/* 行为 2 —— 比较长方体(结构体)的宽度 */</span><span class="token keyword">struct</span> Cuboid array2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wide <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>array2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wide <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>array2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wide <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wide <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Cuboid key2<span class="token punctuation">;</span>key2<span class="token punctuation">.</span>wide <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Cuboid <span class="token operator">*</span>result<span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Cuboid<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">Search</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key2<span class="token punctuation">,</span> array2<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Cuboid<span class="token punctuation">)</span><span class="token punctuation">,</span> Cuboid_WideCmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Found -- "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span>wide<span class="token punctuation">;</span><span class="token keyword">else</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Not Found"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果：Found -- 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，行为2框架下的Search函数功能变为：<strong>寻找与目标长方体宽度相同的长方体</strong>。</p><p>由此可见，行为泛型化在泛型编程中的意义之重大。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr><p>在C++中的<strong>模板</strong>(template) 和<strong>STL标准模板库</strong>(Standard Template Library) 是泛型编程实现的典例。</p><p>而在C语言中，使用void*实现的泛型编程，是极其<strong>有限</strong>的。</p><p>尤其是在安全性方面，系统很难完成全面、有效的检查，需要我们编程时更加严谨、仔细。</p>]]></content>
      
      
      <categories>
          
          <category> 大一下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Const与&amp;与*的花样组合</title>
      <link href="2021/04/27/4.const-yu-yu-zhi-zhen-de-hua-yang-zu-he/"/>
      <url>2021/04/27/4.const-yu-yu-zhi-zhen-de-hua-yang-zu-he/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈指针和引用"><a href="#浅谈指针和引用" class="headerlink" title="浅谈指针和引用"></a>浅谈指针和引用</h1><hr><h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h2><p>在 <em>The C++ Programming Language</em> 中，Bjarne说过：<code>一个声明是自右向左的</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p is a const pointer to char</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p is a pointer to const char</span><span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p is a pointer to const char</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>   对于第三条语句，因为const要去结合类型，即结合char为const char, 所以和第二个是相同的定义类型。<br>   [ 因为单独的一个 * 不属于类型, 即不存在单独的 const* ]<br>   { 如果让我们再回头看第一条语句，其实就是 const 结合了一个类型 char* }</p></blockquote><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h2><p>如果你不清楚引用对象是什么类型的，就<code>(假设可以这样理解)先去掉 &#39;&amp;&#39; 符号，剩下的就是引用对象的类型</code>。</p><p>比如:  const int &amp; 是在引用const int类型的变量。</p><p>​           const int* &amp; 是在引用const int*类型的变量。</p><p>​           那么int * const&amp; 是在引用什么呢？</p><blockquote><p>对于int* const &amp;来说，如果按上面的思路，似乎是在引用 指向int的常指针。<br><strong>但引用一个常量，是没有意义的。</strong><br>所以，该引用应该被理解为<strong>常引用</strong>。<br>当A常引用B时，只能通过A使用B的值，不能通过A修改B。而A仍随B的变化而变化。</p></blockquote><p>再看下面的例子，进一步理解”常引用“。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 定义 */</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> A <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不能引用常量，所以是常引用</span><span class="token keyword">int</span><span class="token operator">&amp;</span> B <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 普通引用</span><span class="token comment" spellcheck="true">/* 赋值 */</span>a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> A<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// OutPut: 30</span>A <span class="token operator">=</span> B<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Fail</span>B <span class="token operator">=</span> A<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>A <span class="token operator">=</span> B<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Success( a = B )</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三者的交叉使用"><a href="#三者的交叉使用" class="headerlink" title="三者的交叉使用"></a>三者的交叉使用</h1><hr><p>接着，让我们看三个例子，来具体地理解一下。</p><p>首先，对所有例子都有：<br>   <code>char c = &#39;0&#39;;</code></p><p><strong>例1</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 定义 */</span><span class="token keyword">char</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 传递 */</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&amp;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Fail</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果：传递失败。<br>报错原因：p1指向char，p2却想引用指向const char的指针p1。<br>                   无法将参数从” char* “转化为” const char *&amp; “。</p></blockquote><p><strong>例2</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 定义 */</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 传递 */</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&amp;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span><span class="token comment" spellcheck="true">/* 赋值 */</span><span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Fail</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果：成功传递，且两次赋值分别成功、失败。<br>即p2是普通引用（引用对象是：指向const char的普通指针 ）</p></blockquote><p><strong>例3</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* 定义 */</span><span class="token keyword">char</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 传递 */</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span><span class="token comment" spellcheck="true">/* 赋值 */</span><span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Fail</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span>p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果：成功传递，且两次赋值分别失败、成功。<br>即p2是常引用（引用对象是：指向char的指针 ）</p></blockquote><h1 id="lt-常引用-gt-的常见用途"><a href="#lt-常引用-gt-的常见用途" class="headerlink" title="&lt;常引用&gt;的常见用途"></a>&lt;常引用&gt;的常见用途</h1><hr><p>最常见的用途是：使用引用传递参数时，如果<strong>不想改变引用对象的值</strong>，则需使用常引用。</p><ul><li><p>  <em>如果不用引用，对于结构类型的参数传递效率可能会很低。</em></p></li><li><p><em>如果不用 const，则原对象可能会修改。</em></p><p>尤其注意——<strong>指针的常引用</strong>容易写错。</p><p>比如:</p><p><code>const char* &amp; A = B;    // 不是常引用</code><br><code>char* const &amp; A = B;    // 是常引用</code></p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr><p>今天下午，突然想整理一下const 、’*’ 、 ‘&amp;’ 之间的关系。</p><p>通过自己的不断测试，便有了如上浅见，希望能帮助到有需要的人。</p>]]></content>
      
      
      <categories>
          
          <category> 大一下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出栈序列</title>
      <link href="2021/04/14/3.chu-zhan-xu-lie/"/>
      <url>2021/04/14/3.chu-zhan-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><hr><p>给定栈的输入序列为1、2、3、…、n，设计算法求出所有可能的出栈序列，并统计个数。</p><blockquote><p>示例：<br>输入： 4<br>输出：<br>            NO.1 is: 4321<br>            NO.2 is: 3421<br>            NO.3 is: 3241<br>            NO.4 is: 3214<br>            NO.5 is: 2431<br>            NO.6 is: 2341<br>            NO.7 is: 2314<br>            NO.8 is: 2143<br>            NO.9 is: 2134<br>            NO.10 is: 1432<br>            NO.11 is: 1342<br>            NO.12 is: 1324<br>            NO.13 is: 1243<br>            NO.14 is: 1234</p></blockquote><h1 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h1><hr><h2 id="1-引例"><a href="#1-引例" class="headerlink" title="1. 引例"></a>1. 引例</h2><hr><p>让我们先来举个例子——对于{ 1, 2, 3 } 的入栈序列来说，<strong>1，2，3均为待入栈的数据</strong>。<br>首先，对 1 进行处理，因为栈中还没有数据，不能出栈，<strong>只能入栈</strong>。</p><ul><li>栈中序列：{ 1 }     已出栈序列：暂无</li></ul><p>接着，对2进行处理，因为栈中有1，所以<strong>既可以push</strong>入2，<strong>也可以pop</strong>出1。<br> a) 若<strong>push</strong>：</p><ul><li><p>栈中序列：{ 2, 1 }    已出栈序列：暂无</p><p>push后，<strong>向后处理</strong>最后一个 3 即可</p></li></ul><p> b) 若<strong>pop</strong>：</p><ul><li><p>栈中序列：暂无      已出栈序列 : { 1 }</p><p>pop后<strong>继续对尚未入栈的2进行处理</strong></p></li></ul><p>……<br>如此循环直到所有元素都入过栈，即1，2，3均被处理完成。<br>此时，<strong>已出栈序列 加上 栈中尚未出栈序列</strong>即为一种答案。<br>【因为最后栈中剩余的是一起pop出栈】</p><h2 id="2-完整思路"><a href="#2-完整思路" class="headerlink" title="2. 完整思路"></a>2. 完整思路</h2><hr><p><strong>【递归 + 回溯】</strong><br>使用<strong>栈S</strong>模拟入栈和出栈的过程，同时使用<strong>数组array</strong>进行已出栈元素的记录</p><blockquote><p>使用数组是为了方便输出；<br>创建数组时，分配n个int内存，<strong>初始化全为0</strong>；<br>【0表示此处尚无出栈元素，同时也可作为输出终止的标志】</p></blockquote><h3 id="递归处理（Recursion-Proccess）"><a href="#递归处理（Recursion-Proccess）" class="headerlink" title="递归处理（Recursion Proccess）"></a><strong>递归处理</strong>（Recursion Proccess）</h3><p>​    (a)  判断递归是否结束，若结束，输出 出栈序列和 栈中尚未出栈序列。<br>​          否则的话进行 b 和 c操作。</p><p>​    (b)  Push：push后，对下一个数据进行Proccess递归。</p><p>​    (c)  Pop：如果不空，进行pop ，将pop的数存入数组，继续对当前数据Proccess递归。<br>​        [此步骤要拿一个<strong>动态局部变量</strong>tmp保留pop出的值]</p><p>对于一条完整的分支，1 – n每个元素都要进行<strong>一次push</strong>操作和<strong>零次或多次pop</strong>操作。</p><h3 id="回溯处理（TraceBack）"><a href="#回溯处理（TraceBack）" class="headerlink" title="回溯处理（TraceBack）"></a><strong>回溯处理</strong>（TraceBack）</h3><p>每次递归操作后，进行回溯（将数组array和栈S回到没处理过的状态）。</p><p>​    (a)  仅执行输出，没有改变数据，无需回溯</p><p>​    (b)  Push：pop完成回溯即可。</p><p>​    (c)  Pop：将数组中元素重新赋值为0，并push回刚刚pop的保留值tmp。</p><p>直到1–n都入栈，[ 递归 ]完成，一条分支结束。<br>直到1–n的 [ 递归+回溯 ] 完成，所有分支结束。<br>因为整个过程都是向前推进的，回溯<strong>只恢复数据</strong>，而不恢复进度，<strong>所有分支都不重复</strong>。</p><h1 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h1><hr><blockquote><p>因为本题在数据结构课程中完成，使用的是自己定义的栈</p></blockquote><h2 id="1-栈类的创建"><a href="#1-栈类的创建" class="headerlink" title="1. 栈类的创建"></a>1. 栈类的创建</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElementType</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">seqStack</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    ElementType<span class="token operator">*</span> Data<span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">seqStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造函数</span>    <span class="token function">seqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> seqStack<span class="token operator">&lt;</span>ElementType<span class="token operator">></span><span class="token operator">&amp;</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 入栈</span>    ElementType <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 出栈</span>    <span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到栈顶的值</span>    ElementType <span class="token function">GetTopNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到栈顶的元素的值</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span>seqStack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出栈的序列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-核心【递归-回溯】"><a href="#2-核心【递归-回溯】" class="headerlink" title="2. 核心【递归 + 回溯】"></a>2. 核心【递归 + 回溯】</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Proccess</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录结果的个数</span>    <span class="token keyword">static</span> seqStack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> S<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 栈的创建</span>    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于pop后的回溯</span>    <span class="token comment" spellcheck="true">/* 结束递归 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 所有元素都已完成入栈操作[即n处理完成]</span>    <span class="token punctuation">{</span>        number<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 结果个数+1</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NO."</span> <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> <span class="token string">" is: "</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 0 即空</span>            cout <span class="token operator">&lt;&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">Print</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 一条分支结束 */</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 未达成结束条件，进行 待入栈数据的push 和 已入栈数据的pop */</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 1.Push */</span>        S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Proccess</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> array<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对下一个数据进行递归处理</span>        S<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 回溯</span>        <span class="token comment" spellcheck="true">/* 2.Pop */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// pop的前提是栈不空</span>        <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>num <span class="token operator">-</span> S<span class="token punctuation">.</span><span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录已出栈元素</span>            <span class="token function">Proccess</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> array<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 继续对该数据进行递归处理【尚未入栈】</span>            array<span class="token punctuation">[</span>num <span class="token operator">-</span> S<span class="token punctuation">.</span><span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 数组的回溯</span>            S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 栈的回溯</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-回归题目"><a href="#3-回归题目" class="headerlink" title="3. 回归题目"></a>3. 回归题目</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please input the value of n: "</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 初始化数组</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">Proccess</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> array<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从 1 开始递归 [n 结束]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，整个题目完成</p><p><strong>拓展</strong>：为了解决入栈序列为{ 3, 7, 9, 2, 4 }之类不规律的问题，只需稍加修改。<br>           将 1–n 变为 TitleArray[0] – TitleArray[n - 1]即可实现，核心算法不变。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr><p>整个思考过程，给我感触颇深。为了将所有情况列出，更是不容在逻辑上存在一点漏洞。<br>一次次的疏漏，带来一次次的苦恼。<br>当正确的结果出现时，无限的激动与欣喜，或许这也就是思考的魅力吧。</p><p>这算是我(偶然)做的第二道算法题了，希望未来的自己看到这篇文章时，会对稚嫩的我，露出欣慰的笑容。</p>]]></content>
      
      
      <categories>
          
          <category> 大一下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 递归与回溯 </tag>
            
            <tag> 简单算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个有序序列的中位数</title>
      <link href="2021/04/10/2.liang-ge-you-xu-xu-lie-de-zhong-wei-shu/"/>
      <url>2021/04/10/2.liang-ge-you-xu-xu-lie-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><hr><p> 整个事件都是在我完成学校老师布置的一道实验题中发生<br>（题目在下一节中给出）</p><p>在第一次做时，我采用了一个<strong>半遍历</strong>的做法【时间O(n)，空间O(1)】，觉得已经完美了。<br>而后来舍友跟我说浙大一老哥用<strong>二分法</strong>做出来了【时间O(log2n)，空间O(1)】，让我觉得可以借鉴。</p><p>后来，老师却一直强调<strong>正确办法是新建一个A和B的并集，再从并集中找中位数</strong>。【时间O(2n)，空间O(2n)】<br>这简直让人匪夷所思呀，这不麻烦去了吗？老师是不是没用心做？</p><p>直到第二次实验，再仔细读题，发现题目上给的是增序序列！<br>之前的半遍历法和二分法统统不符合要求，没有考虑到<strong>重复元素会合并</strong>的特殊情况。</p><p>这样一想，老师的方法是对的。花里胡哨的优化，都被“审题”二字打倒。</p><p>但我不甘心如此复杂的做法呀，于是……</p><h1 id="2-可爱的题目"><a href="#2-可爱的题目" class="headerlink" title="2.可爱的题目"></a>2.可爱的题目</h1><hr><p>（2011年考研原题）</p><p>一个关键字为L（L&gt;=1）的升序序列S（元素不重复），处在第L/2(向下取整)个位置的数称为S的中位数。<br>例如，若序列S1=（11,13,15,17,19）则S1的中位数为15，若两个序列的中位数是含它们所有元素的升序序列的中位数。<br>例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11.<br>现在有两个<strong>等长升序序列</strong>A和B：<br>试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B（组成的升序序列）的中位数。</p><h1 id="3-废弃的两种错误方法"><a href="#3-废弃的两种错误方法" class="headerlink" title="3.废弃的两种错误方法"></a>3.废弃的两种错误方法</h1><hr><p>1是一开始的想法，2是网上的目前最优解。<br>（错误原因是：没考虑到A和B合并后重复元素的影响）</p><h2 id="a-我的思路：半遍历法"><a href="#a-我的思路：半遍历法" class="headerlink" title="a. 我的思路：半遍历法"></a>a. 我的思路：半遍历法</h2><hr><p>让 i(初始化0) 和 j(初始化0) 分别遍历A和B进行循环<br> (循环条件为 <code>i + j &lt; len - 1</code>)<br>【等于len也可以，因为两数相等之后又取了一个更大的数，不影响取中位数】</p><p>a) 当<code>Data1[i] &gt; Data2[j]</code>时， <code>j++</code>;</p><p>b) 当<code>Data1[i] &lt; Data2[j]</code>时， <code>i++</code>;</p><p>c) 当<code>Data1[i] == Data2[j]</code>时，<code>i++</code>,<code>j++</code>;</p><p>此时，判断Data[i]或者Data[j]，谁小谁就是中位数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* Start to search */</span>i <span class="token operator">=</span> j <span class="token operator">=</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> len <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">GetLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// record the length</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// targets found</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Median of them is "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">?</span> list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the smaller one is the median</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="b-网上最优解：二分法"><a href="#b-网上最优解：二分法" class="headerlink" title="b.网上最优解：二分法"></a>b.网上最优解：二分法</h2><hr><p>分别求两个升序序列的 A、B 的中位数 a 和 b，<br>① 若 a = b, 则已找到两个序列的中位数，返回a<br>② 若 a &lt; b, 则舍弃序列 A 中较小的一半， 舍弃序列 B 中较大的一半（考虑奇数偶数）<br>③ 若 a &gt; b, 则舍弃序列 A 中较大的一半， 舍弃序列 B 中较小的一半 （考虑奇数偶数）<br>重复过程 ① 到 ③ 直到两个序列均只含一个元素为止，返回较小者</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">midNum2</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d1 <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m1<span class="token punctuation">,</span> m2<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> s1 <span class="token operator">!=</span> d1 <span class="token operator">||</span> s2 <span class="token operator">!=</span> d2 <span class="token punctuation">)</span> <span class="token punctuation">{</span>        m1 <span class="token operator">=</span> <span class="token punctuation">(</span> s1 <span class="token operator">+</span> d1 <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        m2 <span class="token operator">=</span> <span class="token punctuation">(</span> s2 <span class="token operator">+</span> d2 <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> a<span class="token punctuation">[</span>m1<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>m2<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span>m1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> a<span class="token punctuation">[</span>m1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span>m2<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>s1 <span class="token operator">+</span> d1<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 元素个数为奇数</span>                s1 <span class="token operator">=</span> m1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>                d2 <span class="token operator">=</span> m2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 元素个数为偶数</span>                s1 <span class="token operator">=</span> m1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不保留中间点</span>                d2 <span class="token operator">=</span> m2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>s2 <span class="token operator">+</span> d2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 元素个数为奇数</span>                s2 <span class="token operator">=</span> m2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>                d1 <span class="token operator">=</span> m1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 元素个数为偶数</span>                s2 <span class="token operator">=</span> m2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不保留中间点</span>                d1 <span class="token operator">=</span> m1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保留中间点</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// end of while</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span> a<span class="token punctuation">[</span>s1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span>s2<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">?</span> a<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">:</span> b<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//版权声明：本文为CSDN博主「QiaoDog」的原创文章，遵循CC 4.0 BY-SA版权协议。</span><span class="token comment" spellcheck="true">//原文链接：https://blog.csdn.net/tao20dage/article/details/88848197</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>而这两种方法都可以用以下反例证明错误：<br>A = { 1, 2, 3, 4 }      B = { 1, 2, 5, 6 }      A∪B = { 1, 2, 3, 4, 5, 6 }<br>这两种方法得到的结果都是2，而正确答案是3</p></blockquote><h1 id="4-力挽狂澜的突发奇想"><a href="#4-力挽狂澜的突发奇想" class="headerlink" title="4.力挽狂澜的突发奇想"></a>4.力挽狂澜的突发奇想</h1><hr><p>当发现题目是想要从A和B的并集中找中位数时，万念俱灰，难不成要接受那个复杂的做法了吗？<br>那个 “最优解” 二分法，只是不断的舍弃，却不能实现删除重复元素的操作。</p><p>但此时，我突然想起了我自己曾经的思路：半遍历……<br>于是我把循环条件的原理进行了一番深究：<br>起初，A[i]或者是B[j]代表最小的数；</p><p> <strong>(i + j)的实际意义就是最小的那个数在并集中移动的次数</strong>。</p><p>当走了 len - 1 次的时候，取A[i]和B[j]中最小值，即（不考虑重复元素时）A和B的中位数。</p><blockquote><p>如果最后一步是A[i] == B[j]，也可以通过减去1来实现正常移动 — 详见后面解析。</p></blockquote><p>则此时， <strong>(&lt; len - 1)的实际意义就是最小的那个数到达中位数应当移动的次数。</strong></p><p>如果此时，将重复元素考虑进去，那么为了表示&lt;最小的那个数在并集中移动的次数&gt;和&lt;最小的那个数到达中位数应当移动的次数&gt;:<br>我引入了一个新的变量k和m，分别用于记录重复元素总个数和走过的重复元素个数。<br>当 满足条件A[i] == B[j]后，多执行一条<code>m++;</code>  此时，<strong>记录变量m的数值相当于多走的次数</strong>。<br>（相当于并集的重复元素的删除操作，且不影响空间效率和时间效率）</p><p>于是：<br><strong>&lt;最小的那个数在并集中移动的次数&gt;可以用(i + j - m)来表示。</strong>【因为并集中重复元素不存在】<br><strong>&lt;最小的那个数到达中位数应当移动的次数&gt;可以用 (ceil(((2 * len) - k )/ 2.f) - 1)来表示。</strong>【 ( 2 * len - k ) 就是 并集的实际长度】</p><p>至此，让我们再对之前思路进行修改：</p><p>让 i(初始化0) 和 j(初始化0) 分别遍历A和B进行循环<br> (循环条件为 <code>i + j - m != ceil(((2 * len) - k )/ 2.f) - 1</code>)</p><p>a) 当<code>A[i] &gt; B[j]</code>时， <code>j++</code>;</p><p>b) 当<code>A[i] &lt; B[j]</code>时， <code>i++</code>;</p><p>c) 当<code>A[i] == B[j]</code>时，<code>i++</code>;<code>j++</code>;<code>m++</code>;</p><p>此时，判断A[i]或者B[j]，谁小谁就是中位数。</p><h1 id="5-最优解的代码实现"><a href="#5-最优解的代码实现" class="headerlink" title="5.最优解的代码实现"></a>5.最优解的代码实现</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* Start to search */</span>    i <span class="token operator">=</span> j <span class="token operator">=</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">GetLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// record the length</span>    k <span class="token operator">=</span> <span class="token function">SameNum</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">+</span> j <span class="token operator">-</span> m <span class="token operator">!=</span> <span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">)</span> <span class="token operator">-</span> k <span class="token punctuation">)</span><span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">.</span>f<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// targets found</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            m<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Median of them is "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;</span>list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">?</span>list1<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">:</span>list2<span class="token punctuation">.</span><span class="token function">IndexSearch</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the smaller one is the median</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，整个答案的优化已经完成。</p><ul><li><strong>不需要考虑奇偶</strong></li><li><strong>考虑到了增序的不重复性，还不需要求并集</strong></li><li><strong>时间O(N) 空间O(1)</strong></li></ul><p>此时，这个方法是真真正正的最终完美答案！</p><h1 id="6-结语"><a href="#6-结语" class="headerlink" title="6.结语"></a>6.结语</h1><hr><p> 小小的变化，可以有多少种结果； 小小的改善，又隐藏多少的成长。</p><p>“无限进步 ”才是我们年轻人心里的信仰，对于那份稳重的热情，拥怀着走下去。</p>]]></content>
      
      
      <categories>
          
          <category> 大一下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 简单算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程风格总结</title>
      <link href="2020/11/21/1.bian-cheng-feng-ge-zong-jie/"/>
      <url>2020/11/21/1.bian-cheng-feng-ge-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  为什么风格重要？风格是你的<strong>审美观体现</strong>和<strong>专业性表现</strong>。</p><p>  先来说说什么叫<strong>审美观体现</strong>，“一串普普通通的代码，谈何美感”。每个人的审美观的确是不同的，但却是很容易改变的。每个人都曾会有那么一瞬间觉得——自己之前的作品、行为，是一种不成熟的表现。这其实并不是对与错的区别，而是自己审美观的提升。从一个“不懂得网络规则的小白”成长到一个“拥有自己特色的冲浪者”，是需要一定的审美积累的。创造优秀的作品的前提，一定是拥有了欣赏美的意识。</p><p>  接着，做这一行，最怕被说的就是不专业。而一眼就可看出的风格，恰恰就是你<strong>专业性</strong>的门面。说“没有感觉出专业到哪去”的，只是还没有形成这个意识当中。&lt;毕竟，只是同行才会纠结你专不专业，用户只在乎运行结果&gt;  让我们举个例子吧，刚刚接触调色的萌新应该都干过这么一件蠢事吧——拉高饱和度到过饱。的确，一张平平无奇的照片，当通过后期饱和度的处理后，瞬间变得丰富多彩，甚至超出了自然肉眼的范围。正当你觉得你沉浸在他人的夸赞中、自己很秀的时候，身边一定会有一个老手告诉你：你这过饱，看着好恶心呀！而当你去了解的更深时，才回头意识到自己的愚蠢错误。正如视频出现水印、做ppt全是黑体等等一样，永远都是专业的人能看出你错误，而非专业人士并不会看出这些细节——小却致命的细节。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>  好啊，说了这么多重要性，接下来就讲讲我目前对自己风格的一些总结吧！</p><p>(仅供参考，每个人都应该有各自的风格)</p><h2 id="1-命名风格"><a href="#1-命名风格" class="headerlink" title="1. 命名风格"></a>1. 命名风格</h2><p><strong>英文名词意识:</strong></p><p>如果说你要定义一个整形变量来表示高度<br>不要用<code>int gaodu</code>或是<code>int high</code>;<br>而是要<code>int height</code></p><p><strong>巧用大小写和关联意义:</strong></p><p>如果在我的程序里出现了<code>Str</code>和<code>ch</code><br>我会清楚地告诉你前者是字符数组，后者是字符变量</p><p><strong>注意做标记:</strong></p><p>如果Sum去表示总和<br><code>int iSum</code>和<code>float fSum</code>就可以帮助你在接下来引用时<br>时刻提醒自己用的是什么类型</p><p><strong>“_” 当空格:</strong></p><p>如果真的需要空格<br>比如在First.c文件中全局变量可以写成First_xxx来进行区分。<br>否则合作编程的时候容易出乱子</p><h2 id="2-行文风格"><a href="#2-行文风格" class="headerlink" title="2. 行文风格"></a>2. 行文风格</h2><p><strong>间距意识:</strong></p><blockquote><p>英文符号后一般要加空格</p></blockquote><p>如：<code>int a, b</code>而不是<code>int a,b</code> </p><blockquote><p>运算符和运算量之间要加空格</p></blockquote><p>如：<code>iSum = a + b;</code>而不是<code>iSum=a+b</code> </p><p><strong>标准意识:</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>显然是对的，但是不标准的。建议写成:</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>重视类型:</strong></p><p><code>float a = 0;</code> 应该写成 <code>float a = 0.0f;</code><br><code>double x = 0;</code> 则写成<code>double x = 0.0 ;</code> </p><blockquote><p>不要过于主观给主函数化妆，最标准的主函数写法主要有两种：</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以及</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>声明意识:</strong></p><blockquote><p>头文件声明、宏定义声明、自定义函数声明、全局变量声明 一定要依次有序地放在最开始</p></blockquote><p><strong>对关键步骤一定要做注释:</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义变换符号使用的变量 </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-工程意识"><a href="#3-工程意识" class="headerlink" title="3. 工程意识"></a>3. 工程意识</h2><blockquote><p>编程是一个在效率和工程量之间做衡量的事情，一切都要以实际为根本。</p></blockquote><ul><li><p>效率问题</p></li><li><p>工程量问题</p></li></ul><h2 id="4-注释意识"><a href="#4-注释意识" class="headerlink" title="4. 注释意识"></a>4. 注释意识</h2><blockquote><p>一定要养成在文件最开头写文件说明的习惯！</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//File name  :Date_Sort</span><span class="token comment" spellcheck="true">//Author     :YoungFog</span><span class="token comment" spellcheck="true">//Date       :2020.11.21</span><span class="token comment" spellcheck="true">//Function   :Data Management</span><span class="token comment" spellcheck="true">//Parameter  :0--Success, 1--Failure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  我们总结了这么多规范性风格和个性化风格，没有硬性规定，但一定要在平时注重风格。</p><p>  也许未来我们在企业中会去学习新的风格规范，来达到“便于交流”的最终合作目的。如果我们自己都没有把这份孤僻的事业当成一种热爱的艺术，又怎会说出那句最初的<code>HELLO WORLD</code>？又怎会令初心皈依自己未来的生活？</p><p>  因为我们每个人都是这条道路的开拓者，风格难道不就是我们走过的最好证明吗?</p><p>​                                                                                                                                             写于2020.11.21<br>​                                                                                         一个仅有2个月编程经验却怀揣梦想的大一新生</p>]]></content>
      
      
      <categories>
          
          <category> 大一上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初来乍到 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
